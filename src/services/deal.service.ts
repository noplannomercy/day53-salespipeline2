'use client';

import * as storage from '@/lib/storage';
import { STORAGE_KEYS } from '@/types/index';
import type {
  Deal,
  DealFilters,
  DealWithRelations,
  DealHistoryField,
  Contact,
  Company,
  Stage,
  Pipeline,
  Member,
  Activity,
  Note,
  Email,
  Attachment,
} from '@/types/index';
import * as historyService from '@/services/history.service';

const KEY = STORAGE_KEYS.DEALS;

/**
 * Retrieve all deals, optionally filtered by pipeline, stage, status, priority,
 * assignedTo, company, contact, currency, search term, date range, and value range.
 */
export function getDeals(filters?: DealFilters): Deal[] {
  let items = storage.getAll<Deal>(KEY);

  if (filters?.pipelineId) {
    items = items.filter((d) => d.pipelineId === filters.pipelineId);
  }
  if (filters?.stageId) {
    items = items.filter((d) => d.stageId === filters.stageId);
  }
  if (filters?.status) {
    items = items.filter((d) => d.status === filters.status);
  }
  if (filters?.priority) {
    items = items.filter((d) => d.priority === filters.priority);
  }
  if (filters?.assignedTo) {
    items = items.filter((d) => d.assignedTo === filters.assignedTo);
  }
  if (filters?.companyId) {
    items = items.filter((d) => d.companyId === filters.companyId);
  }
  if (filters?.contactId) {
    items = items.filter((d) => d.contactId === filters.contactId);
  }
  if (filters?.currency) {
    items = items.filter((d) => d.currency === filters.currency);
  }
  if (filters?.search) {
    const q = filters.search.toLowerCase();
    items = items.filter((d) => d.title.toLowerCase().includes(q));
  }
  if (filters?.expectedCloseDateFrom) {
    items = items.filter(
      (d) =>
        d.expectedCloseDate !== null &&
        d.expectedCloseDate >= filters.expectedCloseDateFrom!,
    );
  }
  if (filters?.expectedCloseDateTo) {
    items = items.filter(
      (d) =>
        d.expectedCloseDate !== null &&
        d.expectedCloseDate <= filters.expectedCloseDateTo!,
    );
  }
  if (filters?.valueMin !== undefined) {
    items = items.filter((d) => d.value >= filters.valueMin!);
  }
  if (filters?.valueMax !== undefined) {
    items = items.filter((d) => d.value <= filters.valueMax!);
  }

  return items;
}

/**
 * Retrieve a single deal by ID with related entities joined in memory:
 * Contact, Company, Stage, Pipeline, and assigned Member.
 */
export function getDealById(id: string): DealWithRelations | null {
  const deal = storage.getById<Deal>(KEY, id);
  if (!deal) return null;

  const contact = deal.contactId
    ? storage.getById<Contact>(STORAGE_KEYS.CONTACTS, deal.contactId)
    : null;

  const company = deal.companyId
    ? storage.getById<Company>(STORAGE_KEYS.COMPANIES, deal.companyId)
    : null;

  const stage = deal.stageId
    ? storage.getById<Stage>(STORAGE_KEYS.STAGES, deal.stageId)
    : null;

  const pipeline = deal.pipelineId
    ? storage.getById<Pipeline>(STORAGE_KEYS.PIPELINES, deal.pipelineId)
    : null;

  const assignedMember = deal.assignedTo
    ? storage.getById<Member>(STORAGE_KEYS.MEMBERS, deal.assignedTo)
    : null;

  return {
    ...deal,
    contact,
    company,
    stage,
    pipeline,
    assignedMember,
  };
}

/**
 * Input type for creating a new deal.
 * The id, createdAt, and updatedAt fields are auto-generated by storage.create().
 */
export type CreateDealInput = Omit<Deal, 'id' | 'createdAt' | 'updatedAt'>;

/**
 * Create a new deal. The id, createdAt, updatedAt fields are auto-generated.
 */
export function createDeal(data: CreateDealInput): Deal {
  return storage.create<Deal>(KEY, data);
}

/** Fields tracked for deal change history */
const TRACKED_FIELDS: DealHistoryField[] = [
  'title',
  'value',
  'assignedTo',
  'status',
  'priority',
  'stageId',
];

/**
 * Partially update an existing deal.
 * Records history entries for tracked fields that changed.
 * Returns the updated deal, or null if not found.
 */
export function updateDeal(
  id: string,
  data: Partial<Omit<Deal, 'id' | 'createdAt' | 'updatedAt'>>,
): Deal | null {
  const existing = storage.getById<Deal>(KEY, id);
  if (!existing) return null;

  const changedBy = historyService.getDefaultChangedBy();

  for (const field of TRACKED_FIELDS) {
    if (field in data) {
      const oldVal = String(existing[field] ?? '');
      const newVal = String((data as Record<string, unknown>)[field] ?? '');
      if (oldVal !== newVal) {
        historyService.addHistory(id, field, oldVal, newVal, changedBy);
      }
    }
  }

  return storage.update<Deal>(KEY, id, data);
}

/**
 * Delete a deal by ID.
 * Cleans up related entities: sets dealId to null on Activities, Notes, and Emails
 * that reference this deal. Removes Attachments linked to this deal entity.
 */
export function deleteDeal(id: string): void {
  // Nullify dealId on activities referencing this deal
  const activities = storage.getAll<Activity>(STORAGE_KEYS.ACTIVITIES);
  let activitiesChanged = false;
  const updatedActivities = activities.map((a) => {
    if (a.dealId === id) {
      activitiesChanged = true;
      return { ...a, dealId: null };
    }
    return a;
  });
  if (activitiesChanged) {
    storage.save(STORAGE_KEYS.ACTIVITIES, updatedActivities);
  }

  // Nullify dealId on notes referencing this deal
  const notes = storage.getAll<Note>(STORAGE_KEYS.NOTES);
  let notesChanged = false;
  const updatedNotes = notes.map((n) => {
    if (n.dealId === id) {
      notesChanged = true;
      return { ...n, dealId: null };
    }
    return n;
  });
  if (notesChanged) {
    storage.save(STORAGE_KEYS.NOTES, updatedNotes);
  }

  // Nullify dealId on emails referencing this deal
  const emails = storage.getAll<Email>(STORAGE_KEYS.EMAILS);
  let emailsChanged = false;
  const updatedEmails = emails.map((e) => {
    if (e.dealId === id) {
      emailsChanged = true;
      return { ...e, dealId: null };
    }
    return e;
  });
  if (emailsChanged) {
    storage.save(STORAGE_KEYS.EMAILS, updatedEmails);
  }

  // Remove attachments linked to this deal
  const attachments = storage.getAll<Attachment>(STORAGE_KEYS.ATTACHMENTS);
  const remainingAttachments = attachments.filter(
    (a) => !(a.entityType === 'deal' && a.entityId === id),
  );
  if (remainingAttachments.length !== attachments.length) {
    storage.save(STORAGE_KEYS.ATTACHMENTS, remainingAttachments);
  }

  // Cascade delete deal history
  historyService.deleteDealHistory(id);

  storage.remove(KEY, id);
}

/**
 * Move a deal to a different stage within the same or different pipeline.
 * Returns the updated deal, or throws if the deal is not found.
 */
export function moveDealToStage(dealId: string, stageId: string): Deal {
  const deal = storage.getById<Deal>(KEY, dealId);
  if (!deal) {
    throw new Error(`Deal "${dealId}" not found`);
  }

  // Record stage change history
  if (deal.stageId !== stageId) {
    const changedBy = historyService.getDefaultChangedBy();
    historyService.addHistory(dealId, 'stageId', deal.stageId, stageId, changedBy);
  }

  // Resolve the target stage to update pipelineId if the stage belongs to a different pipeline
  const stage = storage.getById<Stage>(STORAGE_KEYS.STAGES, stageId);
  const pipelineId = stage ? stage.pipelineId : deal.pipelineId;

  const updated = storage.update<Deal>(KEY, dealId, {
    stageId,
    pipelineId,
  } as Partial<Deal>);

  if (!updated) {
    throw new Error(`Failed to update deal "${dealId}"`);
  }

  return updated;
}

/**
 * Close a deal as 'won' or 'lost'.
 * When outcome is 'lost', an optional lostReason can be provided.
 * Returns the updated deal, or throws if the deal is not found.
 */
export function closeDeal(
  dealId: string,
  outcome: 'won' | 'lost',
  lostReason?: string,
): Deal {
  const deal = storage.getById<Deal>(KEY, dealId);
  if (!deal) {
    throw new Error(`Deal "${dealId}" not found`);
  }

  // Record status change history
  if (deal.status !== outcome) {
    const changedBy = historyService.getDefaultChangedBy();
    historyService.addHistory(dealId, 'status', deal.status, outcome, changedBy);
  }

  const updated = storage.update<Deal>(KEY, dealId, {
    status: outcome,
    lostReason: outcome === 'lost' ? (lostReason ?? '') : '',
  } as Partial<Deal>);

  if (!updated) {
    throw new Error(`Failed to close deal "${dealId}"`);
  }

  return updated;
}

/**
 * Clone an existing deal.
 * Copies all domain fields, appends " (복사본)" to the title,
 * resets status to 'open', and creates a new record with fresh timestamps.
 * Returns the newly created deal.
 */
export function cloneDeal(id: string): Deal {
  const original = storage.getById<Deal>(KEY, id);
  if (!original) {
    throw new Error(`Deal "${id}" not found`);
  }

  const cloneData: Omit<Deal, 'id' | 'createdAt' | 'updatedAt'> = {
    pipelineId: original.pipelineId,
    stageId: original.stageId,
    contactId: original.contactId,
    companyId: original.companyId,
    title: original.title + ' (복사본)',
    value: original.value,
    currency: original.currency,
    expectedCloseDate: original.expectedCloseDate,
    priority: original.priority,
    status: 'open',
    lostReason: '',
    assignedTo: original.assignedTo,
  };

  return storage.create<Deal>(KEY, cloneData);
}

/**
 * Get the contact name for a deal (used in table display).
 */
export function getDealContactName(contactId: string): string {
  const contact = storage.getById<Contact>(STORAGE_KEYS.CONTACTS, contactId);
  return contact?.name ?? '-';
}

/**
 * Get the company name for a deal (used in table display).
 */
export function getDealCompanyName(companyId: string | null): string {
  if (!companyId) return '-';
  const company = storage.getById<Company>(STORAGE_KEYS.COMPANIES, companyId);
  return company?.name ?? '-';
}

/**
 * Get the assigned member name for a deal (used in table display).
 */
export function getDealMemberName(assignedTo: string): string {
  if (!assignedTo) return '-';
  const member = storage.getById<Member>(STORAGE_KEYS.MEMBERS, assignedTo);
  return member?.name ?? '-';
}

/**
 * Get the stage name for a deal (used in table display).
 */
export function getDealStageName(stageId: string): string {
  const stage = storage.getById<Stage>(STORAGE_KEYS.STAGES, stageId);
  return stage?.name ?? '-';
}

/**
 * Get the pipeline name for a deal (used in table display).
 */
export function getDealPipelineName(pipelineId: string): string {
  const pipeline = storage.getById<Pipeline>(
    STORAGE_KEYS.PIPELINES,
    pipelineId,
  );
  return pipeline?.name ?? '-';
}
